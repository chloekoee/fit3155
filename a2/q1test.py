from itertools import zip_longest, islice
import sys
from q1 import SuffixTree


def to_int_keys_best(list):
    """
    l: iterable of keys
    returns: a list with integer keys
    """
    seen = set()
    ls = []
    for e in list:
        if e not in seen:
            ls.append(e)
            seen.add(e)
    ls.sort()
    index = {v: i for i, v in enumerate(ls)}
    return [index[v] for v in list]


def suffix_array_best(s):
    """
    suffix array of s
    O(n * log(n)^2)
    """
    n = len(s)
    k = 1
    line = to_int_keys_best(s)
    while max(line) < n - 1:
        line = to_int_keys_best(
            [
                a * (n + 1) + b + 1
                for (a, b) in zip_longest(line, islice(line, k, None), fillvalue=-1)
            ]
        )
        k <<= 1
    return line


def create_test_files(test_string, string_file_name):
    """Write test string and its indices to files."""
    with open(string_file_name, "w") as string_file:
        string_file.write(test_string)


def read_suffix_array_from_output(output_file_name):
    """Read suffix array from the output file generated by the SuffixTree."""
    with open(output_file_name, "r") as file:
        return [int(line.strip()) for line in file.readlines()]


def suffix_array_best(string):
    """Placeholder for the correct suffix array generation algorithm."""
    # This should be replaced with your correct method implementation
    return sorted(range(len(string)), key=lambda i: string[i:])


text_filename = "tests.txt"
tests = open(text_filename).read().split("\n")
count = 0
total_run = 0
smallest_fail = ""

for test in tests:
    if not test.strip():
        continue  # Skip empty lines

    s_arr2 = suffix_array_best(test)
    s_arr2 = [i + 1 for i in s_arr2]  # Adjust for 1-indexing

    string_file_name = "test_string.txt"
    index_file_name = "test_indices.txt"
    output_file_name = "output_q1.txt"

    with open(index_file_name, "w") as index_file:
        indices = [str(i) for i in s_arr2]  # 1-indexing
        index_file.write("\n".join(indices))
    create_test_files(test, string_file_name)

    # Clear output before running
    open(output_file_name, "w").close()

    # Simulate command line arguments and run the SuffixTree
    sys.argv = ["script_name", string_file_name, index_file_name]
    sTree = SuffixTree(string_file_name, index_file_name, encoderMode=False)
    sTree.run()

    # Read output and compare
    s_arr = read_suffix_array_from_output(output_file_name)
    s_arr2 = [i + 1 for i in range(len(test))]
    if s_arr == s_arr2:
        # print(f" test: {test}")
        # print("Got:", s_arr)
        count += 1
    else:
        if smallest_fail == "" or len(test) <= len(smallest_fail):
            smallest_fail = test
            print(f"Failed test: {test}")
            print("Expected:", s_arr2)
            print("Got:", s_arr)

print("Accuracy:", count / len(tests) * 100, "%")
